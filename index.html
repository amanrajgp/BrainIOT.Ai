<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Tank System - Algorithm Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(to bottom, #1e5799, #207cca);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 5px;
        }
        
        .company {
            font-size: 1.4rem;
            font-weight: bold;
            color: #4CAF50;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            margin-bottom: 15px;
        }
        
        .comparison-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
            margin-bottom: 30px;
        }
        
        .tank-comparison {
            flex: 1;
            min-width: 600px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .tanks-side-by-side {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .tank-wrapper {
            flex: 1;
            text-align: center;
        }
        
        .tank-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .raw-tank .tank-title {
            color: #FF9800;
        }
        
        .processed-tank .tank-title {
            color: #4CAF50;
        }
        
        .tank {
            position: relative;
            width: 100%;
            height: 300px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            overflow: hidden;
            border: 3px solid rgba(255, 255, 255, 0.3);
            margin-bottom: 15px;
        }
        
        .water {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #1e5799, #2989d8);
            transition: height 0.5s ease;
            border-radius: 0 0 7px 7px;
        }
        
        .raw-water {
            background: linear-gradient(to top, #FF9800, #FFC107);
        }
        
        .water-level {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        
        .sensor {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 25px;
            background: #333;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.7rem;
            z-index: 10;
        }
        
        .sensor::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 270px;
            background: rgba(255, 255, 255, 0.5);
        }
        
        .tank-data {
            display: flex;
            justify-content: space-around;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .data-item {
            text-align: center;
        }
        
        .data-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .data-value {
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        .controls {
            flex: 1;
            min-width: 300px;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        button {
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .power-btn {
            background: #4CAF50;
            flex: 1;
        }
        
        .power-btn.off {
            background: #f44336;
        }
        
        .config-btn {
            background: #9C27B0;
            margin-top: 10px;
            width: 100%;
        }
        
        .slider-container {
            margin-bottom: 20px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .slider-value {
            font-weight: bold;
        }
        
        .slider {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2196F3;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .fill-slider::-webkit-slider-thumb {
            background: #4CAF50;
        }
        
        .empty-slider::-webkit-slider-thumb {
            background: #FF9800;
        }
        
        .status {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        
        .status-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .status-on {
            background: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }
        
        .status-off {
            background: #f44336;
        }
        
        .data-display {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .comparison-data {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .comparison-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        
        .comparison-label {
            font-weight: bold;
        }
        
        .raw-value {
            color: #FF9800;
        }
        
        .processed-value {
            color: #4CAF50;
        }
        
        .algorithm-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.9rem;
        }
        
        .algorithm-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4CAF50;
        }
        
        .algorithm-desc {
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .flow-animation {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: bubble-rise linear infinite;
        }
        
        @keyframes bubble-rise {
            0% {
                transform: translateY(0) scale(1);
                opacity: 0.7;
            }
            100% {
                transform: translateY(-100px) scale(1.5);
                opacity: 0;
            }
        }
        
        .config-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .config-content {
            background: linear-gradient(to bottom, #2c3e50, #3498db);
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .config-group {
            margin-bottom: 20px;
        }
        
        .config-label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .config-input {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
        }
        
        .config-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .save-btn {
            background: #4CAF50;
            flex: 1;
        }
        
        .cancel-btn {
            background: #f44336;
            flex: 1;
        }
        
        .flow-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .flow-control {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
        }
        
        .flow-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .fill-control {
            border-left: 3px solid #4CAF50;
        }
        
        .empty-control {
            border-left: 3px solid #FF9800;
        }
        
        .net-flow {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            text-align: center;
        }
        
        .net-flow-value {
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .filling {
            color: #4CAF50;
        }
        
        .emptying {
            color: #FF9800;
        }
        
        .balanced {
            color: #2196F3;
        }
        
        footer {
            margin-top: 30px;
            text-align: center;
            opacity: 0.7;
            font-size: 0.9rem;
            width: 100%;
        }
        
        .developer-credit {
            font-size: 1rem;
            font-weight: bold;
            margin-top: 10px;
            color: #FFD700;
        }
        
        @media (max-width: 768px) {
            .comparison-container {
                flex-direction: column;
            }
            
            .tanks-side-by-side {
                flex-direction: column;
            }
            
            .tank-comparison, .controls {
                width: 100%;
                min-width: 100%;
            }
            
            .flow-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Water Tank System Simulation</h1>
            <div class="company">by BrainIOT.AI</div>
            <!-- <p class="subtitle">Comparing raw ultrasonic sensor data vs. Kalman-filtered processed data</p> -->
        </header>
        
        <div class="comparison-container">
            <div class="tank-comparison">
                <h2>Water Tank Comparison</h2>
                
                <div class="tanks-side-by-side">
                    <div class="tank-wrapper raw-tank">
                        <div class="tank-title">Raw Sensor Data</div>
                        <div class="tank">
                            <div class="sensor">US Sensor</div>
                            <div class="water raw-water" id="rawWater"></div>
                            <div class="water-level" id="rawWaterLevel">50%</div>
                            <div class="flow-animation" id="rawFlowAnimation"></div>
                        </div>
                        <div class="tank-data">
                            <div class="data-item">
                                <div class="data-label">Distance</div>
                                <div class="data-value" id="rawDistance">25.0 cm</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Noise Level</div>
                                <div class="data-value" id="rawNoise">High</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="tank-wrapper processed-tank">
                        <div class="tank-title">Processed Data (Kalman Filter)</div>
                        <div class="tank">
                            <div class="sensor">US Sensor</div>
                            <div class="water" id="processedWater"></div>
                            <div class="water-level" id="processedWaterLevel">50%</div>
                            <div class="flow-animation" id="processedFlowAnimation"></div>
                        </div>
                        <div class="tank-data">
                            <div class="data-item">
                                <div class="data-label">Distance</div>
                                <div class="data-value" id="processedDistance">25.0 cm</div>
                            </div>
                            <div class="data-item">
                                <div class="data-label">Noise Level</div>
                                <div class="data-value" id="processedNoise">Low</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="data-display">
                    <h3>Algorithm Performance Comparison</h3>
                    <div class="comparison-data">
                        <div class="comparison-item">
                            <span class="comparison-label">Jitter Level:</span>
                            <span>
                                <span class="raw-value" id="rawJitter">High</span> | 
                                <span class="processed-value" id="processedJitter">Low</span>
                            </span>
                        </div>
                        <div class="comparison-item">
                            <span class="comparison-label">Outlier Rejection:</span>
                            <span>
                                <span class="raw-value" id="rawOutliers">None</span> | 
                                <span class="processed-value" id="processedOutliers">Active</span>
                            </span>
                        </div>
                        <div class="comparison-item">
                            <span class="comparison-label">Response Time:</span>
                            <span>
                                <span class="raw-value" id="rawResponse">Instant</span> | 
                                <span class="processed-value" id="processedResponse">Slightly Delayed</span>
                            </span>
                        </div>
                        <div class="comparison-item">
                            <span class="comparison-label">Stability:</span>
                            <span>
                                <span class="raw-value" id="rawStability">Poor</span> | 
                                <span class="processed-value" id="processedStability">Excellent</span>
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="algorithm-info">
                    <div class="algorithm-title">Enhanced Kalman Filter Algorithm Features:</div>
                    <div class="algorithm-desc">
                        • Adaptive noise filtering with buffer-based outlier rejection<br>
                        • Median filtering with minimum valid sample requirement<br>
                        • Dynamic measurement noise adjustment based on variance<br>
                        • Jump detection with absolute and relative thresholds<br>
                        • Stale sensor detection and handling
                    </div>
                    <div class="algorithm-desc">
                        The processed tank shows significantly reduced jitter and outliers while maintaining accurate water level tracking.
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <h2>Control Panel</h2>
                
                <div class="control-group">
                    <h3>Motor Power</h3>
                    <div class="button-group">
                        <button id="powerBtn" class="power-btn">Power ON</button>
                    </div>
                    <div class="status">
                        <div class="status-indicator status-off" id="statusIndicator"></div>
                        <span id="statusText">Motor is OFF</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Simultaneous Flow Rate Control</h3>
                    
                    <div class="flow-controls">
                        <div class="flow-control fill-control">
                            <div class="flow-title">Fill Rate</div>
                            <div class="slider-container">
                                <div class="slider-label">
                                    <span>Rate:</span>
                                    <span class="slider-value" id="fillRateValue">2.0 %/s</span>
                                </div>
                                <input type="range" min="0.00" max="5" step="0.01" value="0" class="slider fill-slider" id="fillRateSlider">
                            </div>
                            <div class="status">
                                <div class="status-indicator status-on" id="fillStatusIndicator"></div>
                                <span id="fillStatusText">Always Enabled</span>
                            </div>
                        </div>
                        
                        <div class="flow-control empty-control">
                            <div class="flow-title">Empty Rate</div>
                            <div class="slider-container">
                                <div class="slider-label">
                                    <span>Rate:</span>
                                    <span class="slider-value" id="emptyRateValue">1.5 %/s</span>
                                </div>
                                <input type="range" min="0.00" max="5" step="0.01" value="1.0" class="slider empty-slider" id="emptyRateSlider">
                            </div>
                            <div class="status">
                                <div class="status-indicator status-on" id="emptyStatusIndicator"></div>
                                <span id="emptyStatusText">Always Enabled</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="net-flow">
                        <div class="slider-label">
                            <span>Net Flow Rate:</span>
                            <span class="net-flow-value filling" id="netFlowValue">+0.5 %/s</span>
                        </div>
                        <div id="netFlowStatus">Tank is filling</div>
                    </div>
                    
                    <div class="status">
                        <div class="status-indicator status-off" id="flowStatusIndicator"></div>
                        <span id="flowStatusText">No active flow</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Sensor Configuration</h3>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Noise Level:</span>
                            <span class="slider-value" id="noiseLevelValue">Medium</span>
                        </div>
                        <input type="range" min="1" max="3" step="1" value="2" class="slider" id="noiseLevelSlider">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Outlier Frequency:</span>
                            <span class="slider-value" id="outlierValue">5%</span>
                        </div>
                        <input type="range" min="0" max="10" step="1" value="5" class="slider" id="outlierSlider">
                    </div>
                    
                    <button id="configBtn" class="config-btn">Configure Tank Parameters</button>
                </div>
                
                <div class="control-group">
                    <h3>System Status</h3>
                    <div class="data-display">
                        <div class="data-item">
                            <span>Actual Water Level:</span>
                            <span class="data-value" id="actualLevelValue">50%</span>
                        </div>
                        <div class="data-item">
                            <span>Raw Distance:</span>
                            <span class="data-value" id="actualDistanceValue">25.0 cm</span>
                        </div>
                        <div class="data-item">
                            <span>Filtered Distance:</span>
                            <span class="data-value" id="filteredDistanceValue">25.0 cm</span>
                        </div>
                        <div class="data-item">
                            <span>Algorithm Status:</span>
                            <span class="data-value" id="algorithmStatus">Running</span>
                        </div>
                        <div class="data-item">
                            <span>Tank Height:</span>
                            <span class="data-value" id="tankHeightValue">50 cm</span>
                        </div>
                        <div class="data-item">
                            <span>Min Level:</span>
                            <span class="data-value" id="minLevelValue">10%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Water Tank System Simulation | Algorithm Comparison Dashboard</p>
            <div class="developer-credit">This Simulation is developed by Coder.AI a.k.a Aman Raj</div>
        </footer>
    </div>

    <!-- Configuration Modal -->
    <div class="config-modal" id="configModal">
        <div class="config-content">
            <h2>Configure Tank Parameters</h2>
            
            <div class="config-group">
                <label class="config-label" for="tankHeight">Tank Height (cm):</label>
                <input type="number" id="tankHeight" class="config-input" min="10" max="200" step="1" value="50">
                <small>Distance from sensor to tank bottom (Full = 0cm)</small>
            </div>
            
            <div class="config-group">
                <label class="config-label" for="sensorHeight">Sensor Height from Top (cm):</label>
                <input type="number" id="sensorHeight" class="config-input" min="1" max="50" step="1" value="22">
                <small>Distance from sensor to water surface when tank is full</small>
            </div>
            
            <div class="config-group">
                <label class="config-label" for="minWaterLevel">Minimum Water Level (%):</label>
                <input type="number" id="minWaterLevel" class="config-input" min="1" max="30" step="1" value="10">
                <small>Tank will automatically start filling when level drops below this</small>
            </div>
            
            <div class="config-group">
                <label class="config-label" for="tankCapacity">Tank Capacity (Liters):</label>
                <input type="number" id="tankCapacity" class="config-input" min="100" max="10000" step="100" value="1000">
            </div>
            
            <div class="config-buttons">
                <button id="saveConfig" class="save-btn">Save Configuration</button>
                <button id="cancelConfig" class="cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced Kalman Filter Implementation (from your C++ code)
        class EnhancedKalmanFilter {
            constructor(processNoise = 0.01, measurementNoise = 0.1, initialEstimate = 25) {
                this.Q = processNoise;
                this.R = measurementNoise;
                this.x = initialEstimate;
                this.P = 1.0;
                this.K = 0.0;
                
                // Buffer configuration
                this.BUF_SIZE = 10;
                this.readings = new Array(this.BUF_SIZE).fill(0);
                this.readingsValid = new Array(this.BUF_SIZE).fill(false);
                this.bufIndex = 0;
                
                // Filtering parameters
                this.alpha = 0.5;
                this.displayAlpha = 0.08;
                this.ABS_JUMP_THRESHOLD = 50.0;
                this.RELATIVE_JUMP_FACTOR = 3.5;
                this.STALE_THRESHOLD = 8;
                this.MIN_VALID_FOR_MEDIAN = 6;
                
                this.ema = initialEstimate;
                this.displaySmoothed = initialEstimate;
                this.firstFilled = true;
                this.displayInit = true;
            }

            // Compute median of valid values
            computeMedianValid() {
                const tmp = [];
                for (let i = 0; i < this.BUF_SIZE; ++i) {
                    if (this.readingsValid[i]) tmp.push(this.readings[i]);
                }
                if (tmp.length < this.MIN_VALID_FOR_MEDIAN) return NaN;
                
                tmp.sort((a, b) => a - b);
                const mid = Math.floor(tmp.length / 2);
                if (tmp.length % 2 === 0) return (tmp[mid - 1] + tmp[mid]) / 2.0;
                else return tmp[mid];
            }

            // Compute variance of valid samples
            computeVarianceValid() {
                const tmp = [];
                for (let i = 0; i < this.BUF_SIZE; ++i) {
                    if (this.readingsValid[i]) tmp.push(this.readings[i]);
                }
                if (tmp.length === 0) return 1.0;
                
                const mean = tmp.reduce((sum, val) => sum + val, 0) / tmp.length;
                const variance = tmp.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / tmp.length;
                
                return Math.max(variance, 0.01);
            }

            // Predict-only step
            predict() {
                this.P = this.P + this.Q;
                return this.x;
            }

            // Full update using measurement
            update(measurement) {
                // Predict (time update)
                this.P = this.P + this.Q;
                // Measurement update
                this.K = this.P / (this.P + this.R);
                this.x = this.x + this.K * (measurement - this.x);
                this.P = (1 - this.K) * this.P;
                return this.x;
            }

            // Enhanced processing with buffer and outlier rejection
            processWaterLevel(rawReading, tankHeight) {
                let measurementAccepted = false;
                let sensorError = false;

                // Validate rawReading
                if (!isFinite(rawReading)) {
                    this.readings[this.bufIndex % this.BUF_SIZE] = 0.0;
                    this.readingsValid[this.bufIndex % this.BUF_SIZE] = false;
                    this.bufIndex++;
                } else {
                    // Find last valid reading
                    let lastValid = NaN;
                    for (let i = 1; i <= this.BUF_SIZE; ++i) {
                        const idx = (this.bufIndex - i + this.BUF_SIZE) % this.BUF_SIZE;
                        if (this.readingsValid[idx]) {
                            lastValid = this.readings[idx];
                            break;
                        }
                    }

                    let reject = false;
                    if (!isNaN(lastValid)) {
                        const absDiff = Math.abs(rawReading - lastValid);
                        const recentVar = this.computeVarianceValid();
                        const recentStd = Math.sqrt(recentVar);
                        
                        if (absDiff > this.ABS_JUMP_THRESHOLD) reject = true;
                        else if (absDiff > this.RELATIVE_JUMP_FACTOR * recentStd && recentStd > 0.5) reject = true;
                    }
                    
                    this.readings[this.bufIndex % this.BUF_SIZE] = rawReading;
                    this.readingsValid[this.bufIndex % this.BUF_SIZE] = !reject;
                    this.bufIndex++;
                    measurementAccepted = !reject;
                }

                // Process buffer data
                const medianDist = this.computeMedianValid();

                if (this.firstFilled && !isNaN(medianDist)) {
                    this.ema = medianDist;
                    this.firstFilled = false;
                }

                let kalmanOut;
                if (!isNaN(medianDist)) {
                    // EMA over the median
                    this.ema = this.alpha * medianDist + (1 - this.alpha) * this.ema;

                    // Adaptive measurement noise
                    const recentVar = this.computeVarianceValid();
                    const adaptiveR = 0.2 + 0.5 * recentVar;
                    this.R = adaptiveR;

                    // Update Kalman
                    kalmanOut = this.update(this.ema);

                    // Display EMA
                    if (this.displayInit) {
                        this.displaySmoothed = kalmanOut;
                        this.displayInit = false;
                    } else {
                        this.displaySmoothed = this.displayAlpha * kalmanOut + (1 - this.displayAlpha) * this.displaySmoothed;
                    }
                } else {
                    // Predict-only step
                    kalmanOut = this.predict();
                    
                    if (this.displayInit) {
                        this.displaySmoothed = kalmanOut;
                        this.displayInit = false;
                    } else {
                        this.displaySmoothed = this.displayAlpha * kalmanOut + (1 - this.displayAlpha) * this.displaySmoothed;
                    }
                }

                // Stale detection
                let last = NaN;
                let sameCount = 0;
                const checkCount = Math.min(this.BUF_SIZE, this.bufIndex);
                for (let i = 0; i < checkCount; ++i) {
                    const idx = (this.bufIndex - 1 - i + this.BUF_SIZE) % this.BUF_SIZE;
                    if (!this.readingsValid[idx]) continue;
                    if (isNaN(last)) {
                        last = this.readings[idx];
                        sameCount = 1;
                    } else {
                        if (Math.abs(this.readings[idx] - last) < 0.05) sameCount++;
                        else break;
                    }
                }
                if (sameCount >= this.STALE_THRESHOLD) sensorError = true;

                // Convert to percentage
                let percent = 100.0 * (tankHeight - this.displaySmoothed) / tankHeight;
                percent = Math.max(0, Math.min(100, percent));

                return {
                    level: percent,
                    filteredDistance: this.displaySmoothed,
                    measurementAccepted,
                    sensorError
                };
            }

            setMeasurementNoise(newR) {
                if (newR > 0.0) this.R = newR;
            }

            reinit(newEstimate, newP = 1.0) {
                this.x = newEstimate;
                this.P = newP;
            }
        }

        // System state with configurable parameters
        const state = {
            powerOn: false,
            actualWaterLevel: 50, // percentage (ground truth)
            tankPhysicalHeight: 50, // cm - distance from sensor to bottom
            sensorHeight: 22, // cm - distance from sensor to water when full
            minWaterLevel: 10, // percentage - auto refill threshold
            tankCapacity: 1000, // liters
            fillRate: 0.0, // percentage per second
            emptyRate: 1.0, // percentage per second
            noiseLevel: 2, // 1=Low, 2=Medium, 3=High
            outlierFrequency: 5, // percentage
            lastUpdate: new Date(),
            rawDistance: 25, // cm
            filteredDistance: 25, // cm
            autoMode: true
        };

        // Initialize Enhanced Kalman Filter
        const enhancedKalman = new EnhancedKalmanFilter(0.01, 0.5, 25);

        // DOM elements
        const rawWater = document.getElementById('rawWater');
        const rawWaterLevel = document.getElementById('rawWaterLevel');
        const processedWater = document.getElementById('processedWater');
        const processedWaterLevel = document.getElementById('processedWaterLevel');
        const rawDistance = document.getElementById('rawDistance');
        const processedDistance = document.getElementById('processedDistance');
        const rawNoise = document.getElementById('rawNoise');
        const processedNoise = document.getElementById('processedNoise');
        const powerBtn = document.getElementById('powerBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const fillRateSlider = document.getElementById('fillRateSlider');
        const fillRateValue = document.getElementById('fillRateValue');
        const emptyRateSlider = document.getElementById('emptyRateSlider');
        const emptyRateValue = document.getElementById('emptyRateValue');
        const flowStatusIndicator = document.getElementById('flowStatusIndicator');
        const flowStatusText = document.getElementById('flowStatusText');
        const fillStatusIndicator = document.getElementById('fillStatusIndicator');
        const fillStatusText = document.getElementById('fillStatusText');
        const emptyStatusIndicator = document.getElementById('emptyStatusIndicator');
        const emptyStatusText = document.getElementById('emptyStatusText');
        const noiseLevelSlider = document.getElementById('noiseLevelSlider');
        const noiseLevelValue = document.getElementById('noiseLevelValue');
        const outlierSlider = document.getElementById('outlierSlider');
        const outlierValue = document.getElementById('outlierValue');
        const actualLevelValue = document.getElementById('actualLevelValue');
        const actualDistanceValue = document.getElementById('actualDistanceValue');
        const filteredDistanceValue = document.getElementById('filteredDistanceValue');
        const algorithmStatus = document.getElementById('algorithmStatus');
        const tankHeightValue = document.getElementById('tankHeightValue');
        const minLevelValue = document.getElementById('minLevelValue');
        const rawJitter = document.getElementById('rawJitter');
        const processedJitter = document.getElementById('processedJitter');
        const rawOutliers = document.getElementById('rawOutliers');
        const processedOutliers = document.getElementById('processedOutliers');
        const rawResponse = document.getElementById('rawResponse');
        const processedResponse = document.getElementById('processedResponse');
        const rawStability = document.getElementById('rawStability');
        const processedStability = document.getElementById('processedStability');
        const configBtn = document.getElementById('configBtn');
        const configModal = document.getElementById('configModal');
        const saveConfig = document.getElementById('saveConfig');
        const cancelConfig = document.getElementById('cancelConfig');
        const tankHeightInput = document.getElementById('tankHeight');
        const sensorHeightInput = document.getElementById('sensorHeight');
        const minWaterLevelInput = document.getElementById('minWaterLevel');
        const tankCapacityInput = document.getElementById('tankCapacity');
        const netFlowValue = document.getElementById('netFlowValue');
        const netFlowStatus = document.getElementById('netFlowStatus');

        // Initialize the display
        updateWaterDisplays();
        updateSensorData();
        updateConfigDisplay();
        updateFlowStatus();
        updateNetFlowDisplay();
        
        // Set initial slider values
        fillRateValue.textContent = `${state.fillRate.toFixed(2)} %/s`;
        emptyRateValue.textContent = `${state.emptyRate.toFixed(2)} %/s`;
        updateNoiseDisplay();
        updateOutlierDisplay();

        // Power button event
        powerBtn.addEventListener('click', togglePower);

        // Slider events
        fillRateSlider.addEventListener('input', function() {
            state.fillRate = parseFloat(this.value);
            fillRateValue.textContent = `${state.fillRate.toFixed(2)} %/s`;
            updateNetFlowDisplay();
        });

        emptyRateSlider.addEventListener('input', function() {
            state.emptyRate = parseFloat(this.value);
            emptyRateValue.textContent = `${state.emptyRate.toFixed(2)} %/s`;
            updateNetFlowDisplay();
        });

        noiseLevelSlider.addEventListener('input', function() {
            state.noiseLevel = parseInt(this.value);
            updateNoiseDisplay();
        });

        outlierSlider.addEventListener('input', function() {
            state.outlierFrequency = parseInt(this.value);
            updateOutlierDisplay();
        });

        // Configuration modal events
        configBtn.addEventListener('click', function() {
            // Populate current values
            tankHeightInput.value = state.tankPhysicalHeight;
            sensorHeightInput.value = state.sensorHeight;
            minWaterLevelInput.value = state.minWaterLevel;
            tankCapacityInput.value = state.tankCapacity;
            
            configModal.style.display = 'flex';
        });

        saveConfig.addEventListener('click', function() {
            // Save new configuration
            state.tankPhysicalHeight = parseInt(tankHeightInput.value);
            state.sensorHeight = parseInt(sensorHeightInput.value);
            state.minWaterLevel = parseInt(minWaterLevelInput.value);
            state.tankCapacity = parseInt(tankCapacityInput.value);
            
            updateConfigDisplay();
            configModal.style.display = 'none';
        });

        cancelConfig.addEventListener('click', function() {
            configModal.style.display = 'none';
        });

        // Close modal when clicking outside
        configModal.addEventListener('click', function(e) {
            if (e.target === configModal) {
                configModal.style.display = 'none';
            }
        });

        // Update configuration display
        function updateConfigDisplay() {
            tankHeightValue.textContent = `${state.tankPhysicalHeight} cm`;
            minLevelValue.textContent = `${state.minWaterLevel}%`;
        }

        // Update flow status indicators
        function updateFlowStatus() {
            // Both fill and empty are always enabled in simultaneous mode
            fillStatusIndicator.classList.remove('status-off');
            fillStatusIndicator.classList.add('status-on');
            fillStatusText.textContent = 'Always Enabled';
            
            emptyStatusIndicator.classList.remove('status-off');
            emptyStatusIndicator.classList.add('status-on');
            emptyStatusText.textContent = 'Always Enabled';
        }

        // Update net flow display
        function updateNetFlowDisplay() {
            const netFlow = state.fillRate - state.emptyRate;
            const absNetFlow = Math.abs(netFlow).toFixed(2);
            
            if (netFlow > 0) {
                netFlowValue.textContent = `+${absNetFlow} %/s`;
                netFlowValue.className = 'net-flow-value filling';
                netFlowStatus.textContent = 'Tank is filling';
            } else if (netFlow < 0) {
                netFlowValue.textContent = `-${absNetFlow} %/s`;
                netFlowValue.className = 'net-flow-value emptying';
                netFlowStatus.textContent = 'Tank is emptying';
            } else {
                netFlowValue.textContent = `0.00 %/s`;
                netFlowValue.className = 'net-flow-value balanced';
                netFlowStatus.textContent = 'Tank level is stable';
            }
        }

        // Update noise level display
        function updateNoiseDisplay() {
            const levels = ['Low', 'Medium', 'High'];
            noiseLevelValue.textContent = levels[state.noiseLevel - 1];
            rawNoise.textContent = levels[state.noiseLevel - 1];
            processedNoise.textContent = 'Low';
        }

        // Update outlier frequency display
        function updateOutlierDisplay() {
            outlierValue.textContent = `${state.outlierFrequency}%`;
        }

        // Toggle power function
        function togglePower() {
            state.powerOn = !state.powerOn;
            
            if (state.powerOn) {
                powerBtn.textContent = 'Power OFF';
                powerBtn.classList.add('off');
                statusIndicator.classList.remove('status-off');
                statusIndicator.classList.add('status-on');
                statusText.textContent = 'Motor is ON';
                flowStatusIndicator.classList.remove('status-off');
                flowStatusIndicator.classList.add('status-on');
                flowStatusText.textContent = 'Both flows active';
            } else {
                powerBtn.textContent = 'Power ON';
                powerBtn.classList.remove('off');
                statusIndicator.classList.remove('status-on');
                statusIndicator.classList.add('status-off');
                statusText.textContent = 'Motor is OFF';
                flowStatusIndicator.classList.remove('status-off');
                flowStatusIndicator.classList.add('status-on');
                flowStatusText.textContent = 'Both flows active';
            }
            
            updateFlowStatus();
            createBubbles();
        }

        // Update water displays
        function updateWaterDisplays() {
            // Both tanks use the same configuration
            const rawWaterHeight = (state.actualWaterLevel / 100) * 300;
            rawWater.style.height = `${rawWaterHeight}px`;
            rawWaterLevel.textContent = `${Math.round(state.actualWaterLevel)}%`;
            
            const processedWaterHeight = (state.actualWaterLevel / 100) * 300;
            processedWater.style.height = `${processedWaterHeight}px`;
            processedWaterLevel.textContent = `${Math.round(state.actualWaterLevel)}%`;
        }

        // Simulate ultrasonic sensor reading with noise
        function simulateSensorReading() {
            // Calculate actual distance based on water level and configuration
            const actualDistance = state.sensorHeight + 
                ((100 - state.actualWaterLevel) / 100) * (state.tankPhysicalHeight - state.sensorHeight);
            
            // Add noise based on noise level setting
            let noise = 0;
            if (state.noiseLevel === 1) {
                noise = (Math.random() - 0.5) * 1; // Low noise: ±0.5cm
            } else if (state.noiseLevel === 2) {
                noise = (Math.random() - 0.5) * 3; // Medium noise: ±1.5cm
            } else {
                noise = (Math.random() - 0.5) * 6; // High noise: ±3cm
            }
            
            // Occasionally add outliers based on frequency setting
            let outlier = 0;
            if (Math.random() * 100 < state.outlierFrequency) {
                outlier = (Math.random() - 0.5) * 20; // Large outlier: ±10cm
            }
            
            return Math.max(state.sensorHeight, 
                Math.min(state.tankPhysicalHeight, actualDistance + noise + outlier));
        }

        // Update sensor data and apply filtering
        function updateSensorData() {
            // Get raw sensor reading
            state.rawDistance = simulateSensorReading();
            
            // Apply Enhanced Kalman filter processing
            const result = enhancedKalman.processWaterLevel(state.rawDistance, state.tankPhysicalHeight);
            state.filteredDistance = result.filteredDistance;
            const processedLevel = result.level;
            
            // Update displays
            rawDistance.textContent = `${state.rawDistance.toFixed(1)} cm`;
            processedDistance.textContent = `${state.filteredDistance.toFixed(1)} cm`;
            actualLevelValue.textContent = `${Math.round(state.actualWaterLevel)}%`;
            
            // Calculate actual distance for display
            const actualDistance = state.sensorHeight + 
                ((100 - state.actualWaterLevel) / 100) * (state.tankPhysicalHeight - state.sensorHeight);
            actualDistanceValue.textContent = `${actualDistance.toFixed(1)} cm`;
            
            filteredDistanceValue.textContent = `${state.filteredDistance.toFixed(1)} cm`;
            
            // Update algorithm status
            if (result.sensorError) {
                algorithmStatus.textContent = "Sensor Stale";
                algorithmStatus.style.color = "#f44336";
            } else if (!result.measurementAccepted) {
                algorithmStatus.textContent = "Rejecting Outlier";
                algorithmStatus.style.color = "#FF9800";
            } else {
                algorithmStatus.textContent = "Stable";
                algorithmStatus.style.color = "#4CAF50";
            }
            
            // Update comparison metrics
            updateComparisonMetrics();
        }

        // Update comparison metrics
        function updateComparisonMetrics() {
            // Jitter level
            rawJitter.textContent = state.noiseLevel === 1 ? "Low" : state.noiseLevel === 2 ? "Medium" : "High";
            processedJitter.textContent = "Low";
            
            // Outlier rejection
            rawOutliers.textContent = state.outlierFrequency > 0 ? "Present" : "None";
            processedOutliers.textContent = "Active";
            
            // Response time
            rawResponse.textContent = "Instant";
            processedResponse.textContent = "Slightly Delayed";
            
            // Stability
            rawStability.textContent = state.noiseLevel === 1 ? "Good" : state.noiseLevel === 2 ? "Fair" : "Poor";
            processedStability.textContent = "Excellent";
        }

        // Create bubbles animation
        function createBubbles() {
            // Clear existing bubbles
            const rawAnimation = document.getElementById('rawFlowAnimation');
            const processedAnimation = document.getElementById('processedFlowAnimation');
            rawAnimation.innerHTML = '';
            processedAnimation.innerHTML = '';
            
            if (state.powerOn || !state.powerOn) {
                const bubbleCount = state.powerOn ? 10 : 8;
                
                for (let i = 0; i < bubbleCount; i++) {
                    // Raw tank bubbles
                    const rawBubble = document.createElement('div');
                    rawBubble.classList.add('bubble');
                    rawBubble.style.width = `${Math.random() * 8 + 4}px`;
                    rawBubble.style.height = rawBubble.style.width;
                    rawBubble.style.left = `${Math.random() * 80 + 10}%`;
                    rawBubble.style.bottom = `${Math.random() * 30}px`;
                    rawBubble.style.animationDuration = `${Math.random() * 3 + 2}s`;
                    rawAnimation.appendChild(rawBubble);
                    
                    // Processed tank bubbles (fewer/slower to show stability)
                    if (i % 2 === 0) {
                        const processedBubble = document.createElement('div');
                        processedBubble.classList.add('bubble');
                        processedBubble.style.width = `${Math.random() * 6 + 4}px`;
                        processedBubble.style.height = processedBubble.style.width;
                        processedBubble.style.left = `${Math.random() * 80 + 10}%`;
                        processedBubble.style.bottom = `${Math.random() * 30}px`;
                        processedBubble.style.animationDuration = `${Math.random() * 4 + 3}s`;
                        processedAnimation.appendChild(processedBubble);
                    }
                }
            }
        }

        // Main simulation loop
        setInterval(() => {
            // Auto mode logic - refill when below minimum level
            if (state.autoMode && state.actualWaterLevel <= state.minWaterLevel) {
                // When below minimum level, ensure we're filling
                if (state.fillRate <= state.emptyRate) {
                    // Auto-adjust fill rate to be higher than empty rate
                    state.fillRate = state.emptyRate + 0.5;
                    fillRateSlider.value = state.fillRate;
                    fillRateValue.textContent = `${state.fillRate.toFixed(2)} %/s`;
                    updateNetFlowDisplay();
                }
            }
            
            // Apply both fill and empty rates simultaneously (net flow)
            const netFlowRate = state.fillRate - state.emptyRate;
            state.actualWaterLevel += netFlowRate / 10;
            
            // Update flow status based on net flow
            if (netFlowRate > 0) {
                flowStatusText.textContent = 'Net Filling';
            } else if (netFlowRate < 0) {
                flowStatusText.textContent = 'Net Emptying';
            } else {
                flowStatusText.textContent = 'Balanced';
            }
            
            // Clamp water level between 0 and 100
            if (state.actualWaterLevel > 100) state.actualWaterLevel = 100;
            if (state.actualWaterLevel < 0) state.actualWaterLevel = 0;
            
            updateWaterDisplays();
            updateSensorData();
            
            // Add random bubbles occasionally
            if (Math.random() > 0.8) {
                createBubbles();
            }
        }, 100);
    </script>
</body>
</html>
